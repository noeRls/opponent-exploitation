#pragma once

#include <string>
#include <vector>
#include <random>
#include <iostream>
#include <numeric>
#include <string>
#include <functional>

static const std::vector<char> ALL_CARDS_NUMBER = { '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A' };
static const std::string ALL_CARDS_NUMBER_STR = "23456789TJQKA";

enum Suits : char {
    SPADE = 'S',
    DIAMAND = 'D',
    HEARTH = 'H',
    CLUBS = 'C'
};
const std::vector<Suits> SUITS = { SPADE, DIAMAND, HEARTH, CLUBS };

class Card {
    public:
        Card(char number, Suits suit) : number(number), suit(suit) {};
        ~Card() = default;

        std::string getHash() {
            return std::string("") + static_cast<char>(number) + static_cast<char>(suit);
        }

        static std::string getCardsHash(const std::vector<Card> cards) {
            std::string result {};
            for (auto card : cards) {
                result += card.getHash();
            }
            return result;
        }

        bool Card::operator==(const Card &card) const
        {
            return number == card.number && card.suit == suit;
        }

        bool Card::operator!=(const Card &card) const
        {
            return !(*this == card);
        }

        bool Card::operator>(const Card &card) const {
            return getRank() > card.getRank();
        }

        bool Card::operator<(const Card &card) const {
            return getRank() < card.getRank();
        }

        int getRank() const {
            return static_cast<int>(std::distance(ALL_CARDS_NUMBER.begin(), std::find(ALL_CARDS_NUMBER.begin(), ALL_CARDS_NUMBER.end(), number)));
        }

        char number;
        Suits suit;
};

class Dealer {
    public:

        Dealer() : deck(getFullDeck()) {};
        ~Dealer() = default;

        Card drawCard() {
            int idx = rand() % deck.size();
            const auto card = deck[idx];
            deck.erase(deck.begin() + idx);
            return card;
        }

        void removeCards(const std::vector<Card> toRemove) {
            deck.erase(std::remove_if(deck.begin(), deck.end(), [toRemove](const Card &card) {
                return std::find(toRemove.begin(), toRemove.end(), card) != toRemove.end();
            }), deck.end());
        }

        static const std::vector<Card> getFullDeck() {
            std::vector<Card> result = {};
            for (char number : ALL_CARDS_NUMBER) {
                for (Suits suit : SUITS) {
                    result.push_back({ number, suit });
                }
            }
            return result;
        }

    protected:
        std::vector<Card> deck;
};
