#include "rankHand.hpp"

HandCardResult rankHand(std::vector<Card> hand) {
    std::sort(hand.begin(), hand.end(), [](const Card &a, const Card &b) { return a > b; });
    std::unordered_map<Suits, bool> suits = {};
    for (const auto &card : hand) {
        suits[card.suit] = true;
    }
    const bool isFlush = suits.size() == 1;
    const std::string values = std::accumulate(hand.begin(), hand.end(), std::string(""),
        [](std::string result, const Card &card) {
            return std::move(result) + std::to_string(card.number);
        });
    const bool isStraight = ALL_CARDS_NUMBER_STR.find(values) != std::string::npos;
    int cardsCountSum = 0;
    for (const auto &card : hand) {
        cardsCountSum += std::count_if(hand.begin(), hand.end(), [card](const Card &c2) { return card.number == c2.number; } );
    }
    const int score = (2 * cardsCountSum) + 13 * isStraight + 14 * isFlush;
    return {
        score,
        hand,
    };
}

RankHandsResult compareHands5(const std::vector<Card> &hand1, const std::vector<Card> &hand2) {
    const auto r1 = rankHand(hand1);
    const auto r2 = rankHand(hand2);
    if (r1.score != r2.score) {
        return r1.score > r2.score ? WIN : LOSS;
    }
    for (int i = 0; i < r1.sortedCards.size() && i < r2.sortedCards.size(); i++) {
        if (r1.sortedCards[i].getRank() != r2.sortedCards[i].getRank()) {
            return r1.sortedCards[i] > r2.sortedCards[i] ? WIN : LOSS;
        }
    }
    return EQUAL;
}

std::vector<Card> getBestHand7(const std::vector<Card> &hand) {
    std::vector<Card> bestHand = std::vector<Card>(hand.begin(), hand.begin() + 5);
    for (int i = 0; i < hand.size() - 1; i++) {
        for (int i2 = i + 1; i2 < hand.size(); i2++) {
            std::vector<Card> subHand = {};
            for (int x = 0; x < hand.size(); x++) {
                if (x != i && x != i2) {
                    subHand.push_back(hand[x]);
                }
            }
            if (compareHands5(subHand, bestHand) == WIN) {
                bestHand = subHand;
            }
        }
    }
    return bestHand;
}
