# pragma once

#include <string>
#include <functional>
#include <iostream>
#include <optional>

#include "Dealer.hpp"
#include "Exceptions.hpp"
#include "rankHand.hpp"

class Agent {
    public:
        Agent(
            const std::vector<Card> &cards,
            int chips,
            bool hasPlayedThisRound,
            bool bypassValidation = false
        ) : cards(cards), chips(chips), hasPlayedThisRound(hasPlayedThisRound) {
            if (cards.size() != 2 && !bypassValidation) {
                throw InvalidAgentCards();
            }
        };
        ~Agent() = default;

        std::string getHash() const {
            return "hp=" + std::to_string(hasPlayedThisRound) + ";hf=" + std::to_string(hasFold) +
                ";chips="+ std::to_string(chips) + ";cards=" + Card::getCardsHash(cards);
        }

        bool hasFold { false };
        bool hasPlayedThisRound;
        std::vector<Card> cards;
        int chips { 0 };
        int reward { 0 };
};

enum Action {
    FOLD = 0,
    CHECK = 1,
    BET = 2,
    CALL = 3,
    RAISE = 4
};

class PokerEnv {
    public:
        PokerEnv(
            const Agent &a1,
            const Agent &a2,
            const std::vector<Card> publicCards,
            int betnb,
            bool isa1turn
        ) : a1(a1),
            a2(a2),
            publicCards(publicCards),
            betnb(betnb),
            isa1turn(isa1turn)
            {
                dealer.removeCards(a1.cards);
                dealer.removeCards(a2.cards);
                dealer.removeCards(publicCards);
            };
        ~PokerEnv() = default;

        bool isOver() const {
            return a1.hasFold || a2.hasFold || (turnOver() && publicCards.size() == 5);
        }

        bool turnOver() const {
            return a1.hasPlayedThisRound && a2.hasPlayedThisRound && a1.chips == a2.chips;
        }

        void nextTurn() {
            if (publicCards.size() == 5) {
                return;
            }
            a1.hasPlayedThisRound = false;
            a2.hasPlayedThisRound = false;
            betnb = 0;
            int nbToAdd = publicCards.size() == 0 ? 3 : 1;
            for (int i = 0; i < nbToAdd; i++) {
                publicCards.push_back(dealer.drawCard());
            }
        }

        void play(Action action) {
            auto &agent = getPlayingAgent();
            auto &opponent = getOpponent(agent);
            auto available = getAvailableActions();
            if (std::find(available.begin(), available.end(), action) == available.end()) {
                throw InvalidAction();
            }
            switch(action) {
                case BET:
                    agent.chips += 2;
                    betnb += 1;
                    break;
                case CALL:
                    agent.chips = opponent.chips;
                    break;
                case RAISE:
                    agent.chips = opponent.chips;
                    agent.chips += 2;
                    betnb += 1;
                    break;
                case FOLD:
                    agent.hasFold = true;
                    break;
            }
            agent.hasPlayedThisRound = true;
            if (turnOver()) {
                nextTurn();
            }
            isa1turn = !isa1turn;
        }

        Agent &getPlayingAgent() {
            return isa1turn ? a1 : a2;
        }

        const Agent &getPlayingAgent() const {
            return isa1turn ? a1 : a2;
        }

        Agent &getOpponent(const Agent &a) {
            return &a == &a1 ? a2 : a1;
        }

        const Agent &getOpponent(const Agent &a) const {
            return &a == &a1 ? a2 : a1;
        }

        bool canBet() const {
            return betnb < 4;
        }

        std::vector<Action> getAvailableActions() const {
            std::vector<Action> result;
            const auto &agent = getPlayingAgent();
            const auto &opponent = getOpponent(agent);
            if (agent.chips < opponent.chips) {
                result.push_back(FOLD);
                result.push_back(CALL);
                if (canBet()) {
                    result.push_back(RAISE);
                }
            } else {
                result.push_back(CHECK);
                if (canBet()) {
                    result.push_back(BET);
                }
            }
            return result;
        }

        std::string getHash() const {
            return  "a1=" + a1.getHash() + ";a2=" + a2.getHash() + ";pc=" + Card::getCardsHash(publicCards) +
                ";bn=" + std::to_string(betnb) + ";isa1turn=" + std::to_string(isa1turn);
        }

        bool getIsa1turn() const {
            return isa1turn;
        }

        // compute the reward for a1 and a2
        void computeOutcome() {
            if (!isOver()) {
                throw GameNotOver();
            }
            Agent *winner = nullptr;
            Agent *loser = nullptr;
            if (a1.hasFold) {
                winner = &a2;
                loser = &a1;
            } else if (a2.hasFold) {
                winner = &a1;
                loser = &a2;
            } else {
                const auto a1hand = getBestHand7(a1.cards);
                const auto a2hand = getBestHand7(a2.cards);
                const auto result = compareHands5(a1hand, a2hand);
                if (result == EQUAL) {
                    a1.reward = 0;
                    a2.reward = 0;
                    return;
                }
                winner = result == WIN ? &a1 : &a2;
                loser = &getOpponent(*winner);
            }
            winner->reward = loser->chips;
            loser->reward = -loser->chips;
        }

        const Agent &getAgent1() const {
            return a1;
        }

        const Agent &getAgent2() const {
            return a2;
        }

        void assignCardToAgent2() {
            a2.cards = { dealer.drawCard(), dealer.drawCard() };
        }

    private:
        Agent a1;
        Agent a2;
        Dealer dealer {};
        std::vector<Card> publicCards;
        bool isa1turn { true };
        int betnb;
};