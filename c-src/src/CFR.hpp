#pragma once

#include <unordered_map>
#include <iostream>
#include <vector>
#include <numeric>
#include <string>
#include <functional>

#include "PokerEnv.hpp"

struct NodeInfo {
    float regret;
    std::string hash;
    std::unordered_map<std::string, float> strategys;
};

class CFR {
    public:
        CFR();
        ~CFR();

        NodeInfo &getNode(const PokerEnv &env) {
            const auto hash = env.getHash();
            if (nodes.find(hash) == nodes.end()) {
                nodes[hash] = { 0, hash, {} };
            }
            return nodes[hash];
        }

        void runOnce(PokerEnv env, float proba) {
            auto currNode = getNode(env);
            if (env.isOver()) {
                env.assignCardToAgent2();
                env.computeOutcome();
                currNode.regret = env.getAgent1().reward * proba;
                return;
            }
            const auto actions = env.getAvailableActions();
            float total = 0;
            std::vector<NodeInfo *> leadingNodes = {};
            for (const auto action : actions) {
                PokerEnv cpy = env;
                cpy.play(action);
                float p = 1.0f / actions.size();
                auto hash = cpy.getHash();
                if (currNode.strategys.count(hash) == 0) {
                    currNode.strategys[hash] = 1.0f / actions.size();
                }
                runOnce(env, currNode.strategys[hash]);
                leadingNodes.push_back(&getNode(cpy));
            }
            float sumPositiveRegret = std::accumulate(leadingNodes.begin(), leadingNodes.end(), 0.0f,
                [](float total, const NodeInfo *node) { return total + (node->regret > 0 ? node->regret : 0); });
            for (auto node : leadingNodes) {
                currNode.strategys[node->hash] = node->regret > 0 ? node->regret / sumPositiveRegret : 0;
            }
            currNode.regret += proba * std::accumulate(leadingNodes.begin(), leadingNodes.end(), 0.0f,
                [currNode](float total, const NodeInfo *node) { return total + (node->regret * currNode.strategys.at(node->hash)); });
        }

        void run(const PokerEnv &initialEnv, int interation) {
            for (int i = 0; i < interation; i++) {
                runOnce(initialEnv, 1);
            }
        };

    private:
        std::unordered_map<std::string, NodeInfo> nodes {};
};