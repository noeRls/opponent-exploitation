#pragma once

#include <unordered_map>
#include <iostream>
#include <vector>
#include <numeric>
#include <string>
#include <functional>

#include "PokerEnv.hpp"

struct StrategyInfo {
    float value;
    Action action;
};

struct NodeInfo {
    float regret;
    std::string hash;
    std::unordered_map<std::string, StrategyInfo> strategys;
};

class CFR {
    public:
        CFR() = default;
        ~CFR() = default;

        NodeInfo &getNode(const PokerEnv &env) {
            const auto hash = env.getHash();
            if (nodes.find(hash) == nodes.end()) {
                nodes[hash] = { 0, hash, {} };
            }
            return nodes[hash];
        }

        static float getLeadingNodeRegret(const NodeInfo &node)
        {
            return -node.regret;
        }

        void runOnce(PokerEnv env, float proba) {
            // std::cout << proba << " - " << env.getHash() << std::endl;
            auto &currNode = getNode(env);
            if (env.isOver()) {
                env.assignCardToAgent2();
                env.computeOutcome();
                const auto &agent = env.getIsa1turn() ? env.getAgent1() : env.getAgent2();
                // std::cout << "reward a1=" << env.getAgent1().reward << " - " << env.getHash() << std::endl;
                currNode.regret = agent.reward * proba;
                // std::cout << "isover regret=" <<  currNode.regret << std::endl;
                return;
            }
            const auto actions = env.getAvailableActions();
            float total = 0;
            std::vector<NodeInfo *> leadingNodes = {};
            for (const auto action : actions) {
                PokerEnv cpy = env;
                cpy.play(action);
                float p = 1.0f / actions.size();
                auto hash = cpy.getHash();
                if (currNode.strategys.count(hash) == 0) {
                    float value = 1.0f / actions.size();
                    currNode.strategys[hash] = { value, action };
                }
                runOnce(cpy, currNode.strategys[hash].value * proba);
                leadingNodes.push_back(&getNode(cpy));
            }
            float sumNegativeRegret = 0.0f, sumPositiveRegret = 0.0f;
            for (const NodeInfo *node : leadingNodes) {
                const auto regret = getLeadingNodeRegret(*node);
                if (regret > 0) {
                    sumPositiveRegret += regret;
                } else {
                    sumNegativeRegret += regret;
                }
            }
            // std::cout << "isa1" << env.getIsa1turn() << std::endl;
            // std::cout << "sum regret: " << sumPositiveRegret << std::endl;
            // std::cout << "leading node regrets: " << std::endl;
            // for (const auto node : leadingNodes) {
            //     std::cout << node->regret << " - " << node->hash << std::endl;
            // }
            for (auto node : leadingNodes) {
                const auto regret = getLeadingNodeRegret(*node);
                if (sumPositiveRegret > 0) {
                    currNode.strategys[node->hash].value = regret > 0 ? regret / sumPositiveRegret : 0;
                } else {
                    currNode.strategys[node->hash].value = regret == 0 ? 1.0f : 1 - abs(regret / sumNegativeRegret);
                }
            }

            // weight the total
            const float totalStrategy = std::accumulate(leadingNodes.begin(), leadingNodes.end(), 0.0f,
                [currNode](float total, const NodeInfo *node) { return currNode.strategys.at(node->hash).value + total; });
            for (const auto node : leadingNodes) {
                currNode.strategys[node->hash].value /= totalStrategy;
            }

            currNode.regret += proba * std::accumulate(leadingNodes.begin(), leadingNodes.end(), 0.0f,
                [currNode, env](float total, const NodeInfo *node) {
                    return total + (getLeadingNodeRegret(*node) * currNode.strategys.at(node->hash).value);
                });
        }

        std::vector<float> run(const PokerEnv &initialEnv, int interation) {
            std::cout << "running" << std::endl;
            for (int i = 0; i < interation; i++) {
                runOnce(initialEnv, 1);
                std::cout << i << std::endl;
            }
            std::vector<float> result = { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f };
            for (const auto strategy : nodes[initialEnv.getHash()].strategys) {
                std::cout << "action=" << strategy.second.action << std::endl;
                std::cout << "hash=" << strategy.first << std::endl;
                std::cout << "\tstrategy=" << strategy.second.value << std::endl;
                std::cout << "\tregret=" << nodes[strategy.first].regret << std::endl;
                result[static_cast<int>(strategy.second.action)] = strategy.second.value;
            }
            return result;
        };

    private:
        std::unordered_map<std::string, NodeInfo> nodes {};
};