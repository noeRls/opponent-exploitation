#pragma once

#include "PokerEnv.hpp"
#include <unordered_map>
#include <iostream>
#include <vector>
#include <numeric>
#include <string>
#include <functional>

struct NodeInfo {
    int regret;
    std::string hash;
    std::unordered_map<std::string, float> strategys;
};

class CFR {
    public:
        CFR();
        ~CFR();

        NodeInfo &getNode(const PokerEnv &env) {
            const auto hash = env.getHash();
            if (nodes.find(hash) == nodes.end()) {
                nodes[hash] = { 0, hash, {} };
            }
            return nodes[hash];
        }

        void runOnce(PokerEnv env) {
            auto currNode = getNode(env);
            if (env.isOver()) {
                env.computeOutcome();
                currNode.regret = env.getAgent1().reward;
                return;
            }
            const auto actions = env.getAvailableActions();
            float total = 0;
            std::vector<NodeInfo &> leadingNodes = {};
            for (const auto action : actions) {
                PokerEnv cpy = env;
                cpy.play(action);
                runOnce(env);
                leadingNodes.push_back(getNode(cpy));
            }
            int sumPositiveRegret = std::accumulate(leadingNodes.begin(), leadingNodes.end(), 0,
                [](const NodeInfo &node) { return node.regret > 0 ? node.regret : 0; });
            for (auto node : leadingNodes) {
                currNode.strategys[node.hash] = node.regret > 0 ? node.regret / sumPositiveRegret : 0;
            }
            currNode.regret += std::accumulate(leadingNodes.begin(), leadingNodes.end(), 0,
                [currNode](const NodeInfo &node) { return node.regret * currNode.strategys.at(node.hash); });
        }

        void run(const PokerEnv &initialEnv, int interation) {
            for (int i = 0; i < interation; i++) {
                runOnce(initialEnv);
            }
        };

    private:
        std::unordered_map<std::string, NodeInfo> nodes {};
};