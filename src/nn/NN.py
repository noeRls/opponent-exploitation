from __future__ import annotations
from src.utils.plot import save_plot
import shap
from tensorflow import keras
from src.environement.State import State
import numpy as np
from typing import List
import matplotlib.pyplot as plt

import tensorflow as tf
gpus = tf.config.experimental.list_physical_devices('GPU')
for gpu in gpus:
    tf.config.experimental.set_memory_growth(gpu, True)
if len(gpus) > 0:
    print('USING GPU')
    tf.config.experimental.set_virtual_device_configuration(
        gpus[0], [tf.config.experimental.VirtualDeviceConfiguration(memory_limit=1024)])
else:
    print('NOT USING GPU')


class NNGameInfo():
    available_action_size: int
    player_max_action_per_game: int
    game_outcome_size: int

    def __init__(self, state: State) -> None:
        self.available_action_size = state.actions_number
        self.player_max_action_per_game = state.get_max_action_agent()
        self.game_outcome_size = state.game_outcome_size


def shape_to_num_elements(shape):
    total = None
    for num in shape:
        if total is None:
            total = num
        else:
            total *= num
    return total


class NN():
    store_history = False
    history_len = 100
    model: keras.Sequential
    game_info: NNGameInfo
    modelling_size: int
    samples_input: List[np.ndarray]

    def __init__(self, game_info: NNGameInfo, modelling_size: int) -> None:
        self.game_info = game_info
        self.modelling_size = modelling_size
        self.samples_input = []
        self._create_model()

    def get_input_size(self):
        raise NotImplementedError()

    def _create_model(self):
        raise NotImplementedError()

    def set_weights_from_array(self, weights: np.ndarray):
        offset = 0
        for layer in self.model.layers:
            shape = layer.get_weights()[0].shape

            weights_size = layer.get_weights()[0].size
            new_weights = np.reshape(
                weights[offset:offset + weights_size], shape)
            offset += weights_size

            bias_size = shape[-1]
            new_bias = weights[offset:offset + bias_size]
            offset += bias_size

            layer.set_weights([new_weights, new_bias])

    def get_total_weights_size(self):
        weights = self.model.weights
        total = 0
        for w in weights:
            total += w.get_shape().num_elements()
            total += w.get_shape()[-1]  # bias
        return total

    def predict(self, nn_input: np.ndarray):
        if self.store_history:
            self.samples_input.append(nn_input)
            self.samples_input = self.samples_input[-self.history_len:]
        return self.model.predict_on_batch(np.array([nn_input]))[0]

    def copy_model(self, to_copy: NN):
        self.model = keras.models.clone_model(to_copy.model)

    def save(self, path: str):
        self.model.save_weights(path)

    def load(self, path: str):
        self.model.load_weights(path)

    def get_features_name(self) -> List[str]:
        raise NotImplementedError()

    def summary(self, save_path: str = None):
        X = np.array(self.samples_input)
        X_test = X
        explainer = shap.KernelExplainer(
            model=self.model.predict, data=X, link="identity")
        shap_values = explainer.shap_values(np.array(X_test))
        feature_names = self.get_features_name()
        if len(feature_names) != self.get_input_size():
            raise Exception('Invalid feature names len')
        shap.summary_plot(shap_values[0], feature_names, show=save_path==None)
        if save_path: save_plot(save_path, f'action-check-input-impact', True)
        shap.summary_plot(shap_values[1], feature_names, show=save_path==None)
        if save_path: save_plot(save_path, f'action-bet-input-impact', True)
        shap.summary_plot(shap_values[2], feature_names, show=save_path==None)
        if save_path: save_plot(save_path, f'action-fold-input-impact', True)
