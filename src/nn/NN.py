from __future__ import annotations
import numpy as np
from src.environement.State import State
from src.environement.Environment import Environment
from tensorflow import keras

class NNGameInfo():
    available_action_size: int
    player_max_action_per_game: int
    game_outcome_size: int
    def __init__(self, state: State) -> None:
        self.available_action_size = state.actions_number
        self.player_max_action_per_game = state.get_max_action_agent()
        self.game_outcome_size = state.game_outcome_size

def shape_to_num_elements(shape):
    total = None
    for num in shape:
        if total is None:
            total = num
        else:
            total *= num
    return total

class NN():
    model: keras.Sequential
    game_info: NNGameInfo
    modelling_size: int

    def __init__(self, game_info: NNGameInfo, modelling_size: int) -> None:
        self.game_info = game_info
        self.modelling_size = modelling_size
        self._create_model()

    def get_input_size(self):
        raise NotImplementedError()

    def _create_model(self):
        raise NotImplementedError()

    def set_weights_from_array(self, weights: np.ndarray):
        offset = 0
        for layer in self.model.layers:
            shape = layer.get_weights()[0].shape

            weights_size = layer.get_weights()[0].size
            new_weights = np.reshape(weights[offset:offset + weights_size], shape)
            offset += weights_size

            bias_size = shape[-1]
            new_bias = weights[offset:offset + bias_size]
            offset += bias_size

            layer.set_weights([new_weights, new_bias])

    def get_total_weights_size(self):
        weights = self.model.weights
        total = 0
        for w in weights:
            total += w.get_shape().num_elements()
            total += w.get_shape()[-1] # bias
        return total

    def predict(self, input: np.ndarray):
        return self.model.predict(np.array([input]))[0]

    def copy_model(self, to_copy: NN):
        self.model = keras.models.clone_model(to_copy.model)