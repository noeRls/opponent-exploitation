from __future__ import annotations
from src.environement.Strategy import Strategy
from typing import List
import numpy as np


class Individual():
    uid = 0

    startegy: Strategy
    id: int
    won_against: List[Individual]
    lost_against: List[Individual]
    fitness: float

    def __init__(self, strategy: Strategy) -> None:
        Individual.uid += 1
        self.id = Individual.uid
        self.startegy = strategy
        self.reset()

    def reset(self):
        self.fitness = 0
        self.won_against = []
        self.lost_against = []

    def register_win(self, opponent: Individual):
        self.won_against.append(opponent)
        opponent.lost_against.append(self)

    def compute_fitness(self):
        self.fitness = 0
        for i in self.won_against:
            self.fitness += 1.0 / float(len(i.lost_against))
        return self.fitness


class TrainingIndividual(Individual):
    _values: np.ndarray

    def __init__(self, size: int, strategy: Strategy, values: np.ndarray = None) -> None:
        super().__init__(strategy)
        if values is not None and len(values) != size:
            raise Exception(
                f"Invalid values size {len(values)} compared to supplied size {size}")
        self.set_values(values if values is not None else np.random.uniform(
            low=-1, high=1, size=size))

    def _on_values_update(self):
        pass

    def set_values(self, values: np.ndarray):
        self._values = values
        self._on_values_update()

    def apply_mutation(self, mutation_rate):
        mask = np.random.choice(
            [True, False], p=[mutation_rate, 1 - mutation_rate])
        mutation_values = np.random.uniform(
            low=-1, high=1, size=len(self._values))
        self._values[mask] = mutation_values[mask]
        self._on_values_update()

    def copy(self) -> TrainingIndividual:
        return TrainingIndividual(len(self._values), self.startegy.copy(), self._values.copy())
