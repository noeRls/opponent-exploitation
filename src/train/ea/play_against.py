from src.train.ea.Individual import Individual
from src.environement.Environment import Environment
from src.environement.Strategy import Strategy


def play_against(env: Environment, strategy1: Strategy, strategy2: Strategy, nb_games=10, debug=False):
    strategy1.lock.acquire(blocking=True)
    strategy2.lock.acquire(blocking=True)
    strategy1.set_env(env)
    strategy2.set_env(env)
    strategy1.set_agent(env.agent1)
    strategy2.set_agent(env.agent2)
    reward_s1 = 0
    reward_s2 = 0
    states = [env.generate_random_starting_state() for _ in range(nb_games)]
    for step in range(2):
        env.next_game(step == 0)
        for i in range(nb_games):
            env.set_starting_state(states[i], step == 0)
            while not env.game_ended:
                strategy = strategy1 if env.is_p1_turn() else strategy2
                action = strategy.get_play()
                env.play(action)
                if (debug):
                    print(f"{strategy.get_name()} playing {action}")
            reward_s1 += env.agent1.reward
            reward_s2 += env.agent2.reward
            if debug:
                print(
                    f"{strategy1.get_name()}={env.agent1.reward} {strategy2.get_name()}={env.agent2.reward}")
                print(f'r1={reward_s1} r2={reward_s2}')
            strategy1.on_game_end()
            strategy2.on_game_end()
            env.next_game(not env._p1_start)
    strategy1.lock.release()
    strategy2.lock.release()
    return reward_s1, reward_s2
