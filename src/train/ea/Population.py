from typing import List
import numpy as np
from .Individual import Individual
from src.environement.Strategy import Strategy

class TrainingIndividual(Individual):
    values: np.ndarray
    def __init__(self, size: int) -> None:
        super().__init__()
        self.values = np.random.rand(size)

    def apply_mutation(self, mutation_rate):
        mask = np.random.choice([True, False], p=[mutation_rate, 1 - mutation_rate])
        mutation_values = np.random.rand(len(self.values))
        self.values[mask] = mutation_values[mask]

class Population():
    training_individuals: List[TrainingIndividual]
    teaching_set: List[Individual]
    new_individual_per_iteration: int
    mutation_rate: int
    def __init__(self,
        training_individuals: List[TrainingIndividual],
        teaching_set: List[Individual],
        new_individual_per_iteration: int,
        mutation_rate: int
    ) -> None:
        self.teaching_set = teaching_set
        self.training_individuals = training_individuals
        self.new_individual_per_iteration = new_individual_per_iteration
        self.mutation_rate = mutation_rate

    def _select_individuals(self, nb) -> List[TrainingIndividual]:
        total_fitness = float(sum(i.fitness for i in self.training_individuals))
        probability = [i.fitness / total_fitness for i in self.training_individuals]
        selected_indexes = np.random.choice(
            range(len(self.training_individuals)),
            p=probability,
            size=nb
        )
        return [self.training_individuals[i] for i in selected_indexes]

    def _generate_new_pop(self) -> List[TrainingIndividual]:
        new_pop = []
        selected_individuals = self._select_individuals(self.new_individual_per_iteration)
        for individual in selected_individuals:
            new_individual = TrainingIndividual(len(individual.values))
            new_individual.values = individual.values
            new_individual.apply_mutation(self.mutation_rate)
            new_pop.append(new_individual)
        return new_pop

    def _process_selection(self):
        to_remove = self.new_individual_per_iteration
        self.training_individuals.sort(key=lambda x: x.fitness)
        self.training_individuals = self.training_individuals[to_remove:]

    def process_iteration(self):
        new_pop = self._generate_new_pop()
        self._process_selection()
        self.training_individuals += new_pop