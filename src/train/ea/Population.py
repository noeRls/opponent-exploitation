from src.train.ea.play_against import play_against
from src.environement.Environment import Environment
from typing import List
import numpy as np
from .Individual import Individual, TrainingIndividual
from src.environement.Strategy import Strategy
import threading

def two_individual_play(env: Environment, i1: Individual, i2: Individual):
    r1, r2 = play_against(env, i1.startegy, i2.startegy)
    if r1 > r2:
        i1.register_win(i2)
    elif r1 < r2:
        i2.register_win(i1)
    print(f'Game: "{i1.startegy.get_name()}"={r1} "{i2.startegy.get_name()}"={r2}')

def compute_individuals_fitness(env: Environment, individuals: Individual):
    threads: List[threading.Thread] = []
    for x in range(len(individuals)):
        i1 = individuals[x]
        for y in range(x + 1, len(individuals)):
            i2 = individuals[y]
            thread = threading.Thread(target=two_individual_play, args=(env.create_new(), i1, i2))
            thread.start()
            threads.append(thread)
    for t in threads:
        t.join()
    for individual in individuals:
        individual.compute_fitness()
        print(f'Fitness "{individual.startegy.get_name()}"={individual.fitness}')

class Population():
    training_individuals: List[TrainingIndividual]
    teaching_set: List[Individual]
    new_individual_per_iteration: int
    mutation_rate: int
    def __init__(self,
        training_individuals: List[TrainingIndividual],
        teaching_set: List[Individual],
        new_individual_per_iteration: int,
        mutation_rate: int
    ) -> None:
        self.teaching_set = teaching_set
        self.training_individuals = training_individuals
        self.new_individual_per_iteration = new_individual_per_iteration
        self.mutation_rate = mutation_rate

    def _select_individuals(self, nb) -> List[TrainingIndividual]:
        total_fitness = float(sum(i.fitness for i in self.training_individuals))
        if total_fitness == 0:
            probability = None
        else:
            probability = [i.fitness / total_fitness for i in self.training_individuals]
        selected_indexes = np.random.choice(
            range(len(self.training_individuals)),
            p=probability,
            size=nb
        )
        return [self.training_individuals[i] for i in selected_indexes]

    def _generate_new_pop(self) -> List[TrainingIndividual]:
        new_pop = []
        selected_individuals = self._select_individuals(self.new_individual_per_iteration)
        for individual in selected_individuals:
            new_individual = individual.copy()
            print(f'{new_individual.startegy.id} heriting from - {individual.startegy.id}')
            new_individual.apply_mutation(self.mutation_rate)
            new_pop.append(new_individual)
        return new_pop

    def _process_selection(self):
        to_remove = self.new_individual_per_iteration
        self.training_individuals.sort(key=lambda x: x.fitness)
        self.training_individuals = self.training_individuals[to_remove:]

    def process_iteration(self, env: Environment):
        for i in self.teaching_set + self.training_individuals:
            i.reset()
        compute_individuals_fitness(env, self.teaching_set + self.training_individuals)
        new_pop = self._generate_new_pop()
        self._process_selection()
        self.training_individuals += new_pop

    def get_best_individual(self):
        best_individual = self.training_individuals[0]
        for individual in self.training_individuals:
            if (individual.fitness > best_individual.fitness):
                best_individual = individual
        return individual