from ..Environment import Environment
from .KuhnInfo import KuhnAction, random_card
from .KuhnAgent import KuhnAgent
from ..State import State

class KuhnEnv(Environment):
    pot: int

    def generate_random_starting_state(self):
        return { "agent1": random_card(), "agent2": random_card() }

    def set_starting_state(self, state, inverse_player):
        a1 = self.agent1 if inverse_player == False else self.agent2
        a2 = self.agent2 if inverse_player == False else self.agent1
        a1.card = state["agent1"]
        a2.card = state["agent2"]

    def create_state(self):
        self._state = State(actions_number=len(list(KuhnAction)), max_actions_in_game=3, game_outcomse_size=1)

    def create_agents(self):
        self.agent1 = KuhnAgent(self._state)
        self.agent2 = KuhnAgent(self._state)

    def _is_game_ended(self):
        return (
            (self.agent1.has_bet() and self.agent2.has_bet())
            or (self.agent1.has_bet() and self.agent2.has_fold())
            or (self.agent2.has_bet() and self.agent1.has_fold())
            or (
                len(self._state.action_history) == 2
                and self._state.action_history[0] == KuhnAction.CHECK
                and self._state.action_history[1] == KuhnAction.CHECK
            )
        )

    def _on_game_end(self):
        winner = None
        if self.agent1.has_fold():
            winner = self.agent2
        elif self.agent2.has_fold():
            winner = self.agent1
        else:
            self.agent1.revealed = True
            self.agent2.revealed = True
            print(f'{self.agent1.card} {self.agent2.card}')
            if self.agent1.card != self.agent2.card:
                print('not same card')
                winner = self.agent1 if self.agent1.card.value > self.agent2.card.value else self.agent2
        if winner:
            winner.reward += self.pot
        else:
            self.agent1.reward = 0
            self.agent2.reward = 0

    def play(self, action):
        if action == KuhnAction.BET or action == KuhnAction.CALL:
            agent = self.get_playing_agent()
            agent.reward -= 1
            self.pot += 1
        super().play(action)

    def next_game(self, p1_start=True):
        super().next_game(p1_start)
        self.agent1.reward -= 1
        self.agent2.reward -= 1
        self.pot = 2

    def get_available_actions(self):
        if (self.agent1.has_bet() or self.agent2.has_bet()):
            return [KuhnAction.FOLD, KuhnAction.CALL]
        else:
            return [KuhnAction.CHECK, KuhnAction.BET]