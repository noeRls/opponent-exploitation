from __future__ import annotations
from ..Environment import Environment
from .KuhnInfo import KuhnAction
from .KuhnAgent import KuhnAgent
from .KuhnDealer import KuhnDealer
from ..State import State
import numpy as np


class KuhnEnv(Environment):
    pot: int

    def generate_random_starting_state(self):
        dealer = self._create_dealer()
        return {"agent1": dealer.draw_card(), "agent2": dealer.draw_card()}

    def set_starting_state(self, state, inverse_player):
        a1 = self.agent1 if inverse_player == False else self.agent2
        a2 = self.agent2 if inverse_player == False else self.agent1
        a1.card = state["agent1"]
        a2.card = state["agent2"]

    def create_state(self):
        self.state = State(actions_number=len(
            list(KuhnAction)), max_actions_in_game=3, game_outcome_size=1)

    def create_agents(self):
        self.agent1 = KuhnAgent(self.state)
        self.agent2 = KuhnAgent(self.state)

    def _is_game_ended(self):
        return (
            (self.agent1.has_bet() and self.agent2.has_bet())
            or (self.agent1.has_bet() and self.agent2.has_fold())
            or (self.agent2.has_bet() and self.agent1.has_fold())
            or (
                len(self.state.action_history) == 2
                and self.state.action_history[0] == KuhnAction.CHECK
                and self.state.action_history[1] == KuhnAction.CHECK
            )
        )

    def _on_game_end(self):
        winner = None
        if self.agent1.has_fold():
            winner = self.agent2
        elif self.agent2.has_fold():
            winner = self.agent1
        else:
            self.agent1.revealed = True
            self.agent2.revealed = True
            winner = self.agent1 if self.agent1.card.value > self.agent2.card.value else self.agent2
        if winner:
            winner.reward += self.pot
        else:
            self.agent1.reward = 0
            self.agent2.reward = 0

    def transform_action_to_enum(self, action):
        return KuhnAction(action)

    def play(self, action):
        action = self.transform_action_to_enum(action)
        if action == KuhnAction.BET or action == KuhnAction.CALL:
            agent = self.get_playing_agent()
            agent.reward -= 1
            self.pot += 1
        super().play(action)

    def _create_dealer(self) -> KuhnDealer:
        return KuhnDealer()

    def next_game(self, p1_start=True, dealer=None):
        super().next_game(p1_start, dealer)
        self.agent1.reward -= 1
        self.agent2.reward -= 1
        self.pot = 2
        self.agent1.card = self._dealer.draw_card()
        self.agent2.card = self._dealer.draw_card()

    def get_available_actions(self):
        if (self.agent1.has_bet() or self.agent2.has_bet()):
            return [KuhnAction.FOLD, KuhnAction.CALL]
        else:
            return [KuhnAction.CHECK, KuhnAction.BET]

    def game_outcome_array_for_agent(self, agent: KuhnAgent) -> np.ndarray:
        return np.array([agent.reward])

    def create_new(self) -> KuhnEnv:
        return KuhnEnv()
