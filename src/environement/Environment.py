from __future__ import annotations
import numpy as np
from .Agent import Agent
from .State import State
from .Dealer import Dealer

class Environment():
    game_ended: bool
    _p1_turn: bool
    _p1_start: bool
    agent1: Agent
    agent2: Agent
    state: State
    _dealer: Dealer

    def __init__(self):
        self._p1_start = False
        self.create_state()
        self.create_agents()
        self.next_game(True)

    def _create_dealer(self):
        raise NotImplementedError()

    def generate_random_starting_state(self):
        raise NotImplementedError()

    def set_starting_state(self, state, inverse_player):
        raise NotImplementedError()

    def create_state(self):
        raise NotImplementedError()

    def create_agents(self):
        raise NotImplementedError()

    def get_starting_agent(self):
        return self.agent1 if self._p1_start else self.agent2

    def get_playing_agent(self):
        return self.agent1 if self._p1_turn else self.agent2

    def get_opponent(self, agent):
        if (agent == self.agent1):
            return self.agent2
        else:
            return self.agent1

    def get_available_actions(self):
        raise NotImplementedError()

    def is_p1_turn(self):
        return self._p1_turn

    def _is_game_ended(self):
        raise NotImplementedError()

    def _on_game_end(self):
        raise NotImplementedError()

    def transform_action_to_enum(self, action):
        raise NotImplementedError()

    def play(self, action):
        action = self.transform_action_to_enum(action)
        if self.game_ended:
            raise Exception('Game is ended, no action can be played')
        if action not in self.get_available_actions():
            raise Exception(f'Action {action} is not available')
        agent = self.get_playing_agent()
        agent.play(action)
        self.state.action_history.append(action)
        self.game_ended = self._is_game_ended()
        if (self.game_ended):
            self._on_game_end()
        self._p1_turn = not self._p1_turn

    def p1_start_this_game(self):
        return self._p1_start

    def next_game(self, p1_start=True):
        self.game_ended = False
        self._p1_start = p1_start
        self._p1_turn = self._p1_start
        self.state.reset()
        self._dealer.reset()
        self.agent1.reset(self._p1_start)
        self.agent2.reset(not self._p1_start)
        if not self._p1_start:
            self.agent1._step += 1

    def game_outcome_array_for_agent(self, agent: Agent) -> np.ndarray:
        raise NotImplementedError()

    def create_new(self) -> Environment:
        raise NotImplementedError()
